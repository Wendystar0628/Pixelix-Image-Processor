# 数据分析图统一更新机制 实施计划

- [ ] 1. **创建UI可见性状态管理器 (`ViewStateManager`)**
  - 在 `app/ui/managers/` 目录下创建 `view_state_manager.py` 文件。
  - 在文件中定义 `ViewStateManager` 类，使其成为一个单例或可全局访问的实例。
  - 实现 `set_panel_visibility(panel_id: str, is_visible: bool)` 方法，用于更新面板的可见状态。
  - 实现 `is_panel_visible(panel_id: str) -> bool` 方法，用于查询状态。
  - 定义一个PyQt信号 `view_state_changed = Signal(str, bool)`，在 `set_panel_visibility` 中当状态改变时发射此信号。
  - _需求: 3.2_

- [ ] 2. **创建分析更新协调器 (`AnalysisUpdateManager`)**
  - 在 `app/core/managers/` 目录下创建 `analysis_update_manager.py` 文件。
  - 定义 `AnalysisUpdateManager` 类，同样使其易于全局访问。
  - 实现 `register_panel(panel_id: str, panel_instance)` 方法，用于存储所有分析面板的引用。
  - 内部维护一个 `stale_panels: set` 来跟踪需要更新的隐藏面板。
  - _需求: 3.1, 3.3_

- [ ] 3. **实现核心更新与调度逻辑**
  - 在 `AnalysisUpdateManager` 中创建 `handle_data_updated(image_id: str)` 方法。
    - 该方法遍历所有已注册的面板。
    - 调用 `ViewStateManager.is_panel_visible()` 判断面板可见性。
    - 如果可见，立即调用面板的更新方法（如 `panel.trigger_update()`）。
    - 如果不可见，则将其ID添加到 `stale_panels` 集合中。
  - 在 `AnalysisUpdateManager` 中创建 `handle_view_state_changed(panel_id: str, is_visible: bool)` 方法。
    - 如果 `is_visible` 为 `True` 且 `panel_id` 在 `stale_panels` 中，则调用该面板的更新方法，并从集合中移除其ID。
  - _需求: 1.1, 2.1, 2.2_

- [ ] 4. **创建渲染器抽象层**
  - 在 `app/ui/renderers/` 目录下创建 `base_renderer.py` 文件。
  - 在文件中定义抽象基类 `RendererInterface`，包含一个抽象方法 `render(self, target_widget, data)`。
  - 在 `app/ui/renderers/` 目录下创建 `matplotlib_renderer.py`。
  - 定义 `MatplotlibRenderer` 类，继承 `RendererInterface` 并实现 `render` 方法，封装 Matplotlib 的绘图逻辑。
  - 在 `app/ui/renderers/` 目录下创建 `pyqt_renderer.py`。
  - 定义 `PyQtGraphRenderer` 类，继承 `RendererInterface` 并实现 `render` 方法，封装 PyQtGraph 的绘图逻辑。
  - _需求: 4.1, 4.2, 4.3_

- [ ] 5. **改造分析面板以集成新机制**
  - 创建或修改一个基类 `BaseAnalysisPanel` 在 `app/ui/panels/base_analysis_panel.py`。
  - 所有具体的分析面板（如 `HistogramPanel`, `WaveformPanel`）应继承自 `BaseAnalysisPanel`。
  - 在 `BaseAnalysisPanel` 中添加 `set_renderer(self, renderer)` 方法，并持有一个 `self.renderer` 实例。
  - 在 `BaseAnalysisPanel` 中重写 `showEvent` 和 `hideEvent` 方法，与 `ViewStateManager` 通信。
  - 修改 `trigger_update()` 方法，使其调用 `self.renderer.render()` 来执行绘图，从而解耦具体的渲染库。
  - _需求: 3.3_

- [ ] 6. **连接信号与槽并配置渲染器**
  - 在应用程序的初始化部分，实例化 `ViewStateManager` 和 `AnalysisUpdateManager`。
  - 根据当前的渲染模式（Matplotlib 或 PyQt）创建对应的渲染器实例。
  - 在创建每个分析面板实例后，调用 `panel.set_renderer()` 配置其渲染器，并调用 `AnalysisUpdateManager.register_panel()` 进行注册。
  - 连接 `signals.data_updated` 和 `ViewStateManager.view_state_changed` 信号到 `AnalysisUpdateManager` 的相应槽函数。
  - _需求: 3.1, 4.3_

- [ ] 7. **测试与验证**
  - 在 Matplotlib 模式下，运行应用程序并打开一个分析面板。
    - 验证可见面板立即更新，隐藏面板延迟更新。
  - 切换到 PyQt 模式下，运行应用程序并打开一个分析面板。
    - 再次验证可见面板立即更新，隐藏面板延迟更新。
  - 确保在两种模式下，功能表现一致且符合预期。
  - _需求: 1.1, 1.3, 2.1, 2.2, 4.1, 4.2_
