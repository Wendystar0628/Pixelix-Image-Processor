# Config-Interfaces循环导入根本修复需求文档

## 介绍

当前应用存在严重的Config-Interfaces循环导入问题：config.py导入core.interfaces中的ConfigManagerInterface，而core层组件通过服务构建器间接依赖config模块，形成循环依赖链。同时，现有代码结构违反了单一职责原则，如config.py承担数据定义、服务实现、接口依赖三重职责，main.py成为了包含启动、创建、配置、信号连接等多重职责的"God Function"。这导致app/core/__init__.py的第5-6行接口导入被迫注释，严重影响了接口模块的正常使用。需要通过基础设施层重构和严格的单一职责分离彻底解决这些架构违反问题。

## 需求

### 需求 1: 彻底消除Config-Interfaces循环导入

**用户故事:** 作为开发者，我希望config.py不再直接导入core.interfaces，这样就不会形成循环依赖链

#### 验收标准

1. WHEN config.py需要配置接口定义时 THEN 系统 SHALL 从独立的基础设施层获取接口而不是core.interfaces
2. WHEN core.interfaces模块导入时 THEN 系统 SHALL 不会触发config.py的加载
3. WHEN 应用启动时 THEN 系统 SHALL 无任何循环导入错误

### 需求 2: 建立基础设施层分离

**用户故事:** 作为架构师，我希望建立独立的基础设施层管理配置服务，这样配置关注点与业务关注点完全分离

#### 验收标准

1. WHEN 系统需要配置服务时 THEN 配置服务 SHALL 位于独立的infrastructure层
2. WHEN 基础设施层提供服务时 THEN 它 SHALL 不依赖任何业务层组件
3. WHEN 核心层需要配置时 THEN 系统 SHALL 通过核心抽象层访问配置服务

### 需求 3: 恢复核心接口模块完整功能

**用户故事:** 作为开发者，我希望app/core/__init__.py能够正常导入所有接口，这样核心接口可以正常使用

#### 验收标准

1. WHEN 导入app.core时 THEN 系统 SHALL 能够成功导入所有interfaces
2. WHEN 使用核心接口时 THEN 所有接口 SHALL 通过app.core.interfaces正常访问
3. WHEN 检查core模块时 THEN 系统 SHALL 不包含任何被注释的导入语句

### 需求 4: 重构依赖注入流程

**用户故事:** 作为开发者，我希望依赖注入流程不产生循环导入，这样服务创建过程稳定可靠

#### 验收标准

1. WHEN 服务构建器创建服务时 THEN 它 SHALL 通过基础设施桥接器访问配置
2. WHEN 基础设施服务注册时 THEN 系统 SHALL 使用工厂模式避免直接导入
3. WHEN 依赖注入完成时 THEN 所有配置依赖 SHALL 通过核心抽象层访问

### 需求 5: 建立核心抽象层

**用户故事:** 作为架构师，我希望在核心层和基础设施层之间建立抽象层，这样两层可以松耦合协作

#### 验收标准

1. WHEN 核心层需要基础设施能力时 THEN 系统 SHALL 通过核心抽象层接口访问
2. WHEN 基础设施层实现服务时 THEN 它 SHALL 实现核心抽象层定义的接口
3. WHEN 抽象层接口设计时 THEN 它 SHALL 只定义核心业务真正需要的最小能力集

### 需求 6: 严格遵循单一职责原则

**用户故事:** 作为开发者，我希望每个代码文件都只承担一种职责，这样代码更容易理解、修改和测试

#### 验收标准

1. WHEN 检查任何代码文件时 THEN 该文件的职责 SHALL 可以用一句话（不超过15个字）清晰描述
2. WHEN 需要修改文件时 THEN 修改的原因 SHALL 不超过一个
3. WHEN 文件包含多个类或函数时 THEN 它们 SHALL 都服务于同一个职责

### 需求 7: 分离config.py多重职责

**用户故事:** 作为开发者，我希望config.py不再承担数据定义、服务实现、接口依赖三重职责，这样职责边界更清晰

#### 验收标准

1. WHEN 需要配置数据模型时 THEN AppConfig SHALL 位于独立的models模块中
2. WHEN 需要配置管理功能时 THEN ConfigManager SHALL 位于基础设施层
3. WHEN 使用现有导入时 THEN config.py SHALL 作为向后兼容层重新导出相关组件

### 需求 8: 分离main.py God Function

**用户故事:** 作为开发者，我希望main.py不再是包含启动、创建、配置、信号连接等多重职责的"God Function"，这样启动逻辑更清晰

#### 验收标准

1. WHEN main.py作为应用入口时 THEN 它 SHALL 只负责创建启动器并调用，代码不超过15行
2. WHEN 需要复杂启动逻辑时 THEN 系统 SHALL 使用独立的ApplicationStartup协调器
3. WHEN 启动过程出现异常时 THEN ApplicationStartup SHALL 负责异常处理和清理

## 非功能需求

### 架构清晰性要求

1. 依赖关系必须严格单向：Application → Business → Abstractions ← Infrastructure
2. 每层职责边界必须清晰明确，无职责越界
3. 分层违反必须在代码审查阶段被发现
4. 单一职责原则违反必须在开发阶段被检测

### 单一职责原则要求

1. 每个文件的职责必须可以用一个动词短语描述
2. 文件内所有代码必须服务于同一个职责
3. 类和方法的职责必须单一明确
4. 修改文件的原因不能超过一个

### 向后兼容性要求

1. 现有配置访问接口保持不变
2. 现有导入路径继续可用（如from app.config import ConfigManager）
3. 应用启动流程保持稳定
4. 业务功能不受影响

### 简单性要求

1. 新增代码文件不超过12个
2. 单个文件代码行数控制在80行以内（除非是纯数据模型）
3. 避免过度设计和复杂抽象
4. 文件职责描述不超过15个字

### 开发效率要求

1. 代码修改的影响范围可控
2. 文件职责清晰易于理解和修改
3. 错误定位和调试效率提升
4. 新功能开发有明确的放置指导

### 可维护性要求

1. 新开发者能够快速理解各层职责和文件职责
2. 配置相关的问题易于定位和调试
3. 架构变更的影响范围可控
4. 单一职责使得代码修改风险降低

### 代码质量要求

1. 每个文件都有明确的职责文档说明
2. 文件复杂度指标（如圈复杂度）保持在合理范围
3. 类和方法的设计符合SOLID原则
4. 代码审查必须包含单一职责原则检查

### 测试要求

1. 每个单一职责的文件都能独立进行单元测试
2. 文件职责的修改不应影响其他文件的测试
3. 集成测试必须验证各层协作的正确性
4. 回归测试必须确保功能完整性