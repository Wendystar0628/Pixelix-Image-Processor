# 技术设计文档

## 1. 概述 (Overview)

- **目标 (Goal)**: 根除在切换渲染引擎时因资源管理不当引发的性能下降和内存泄露问题。
- **背景 (Context)**: 当前 `AnalysisPanel` 的实现会在每次切换渲染引擎时创建新的 `AnalysisComponentsManager` 实例，但从不销毁旧的实例和UI组件，导致资源累积，性能雪崩。
- **范围 (Scope)**: 本次重构仅限于 `app/ui/panels/analysis_panel.py` 文件。不会影响其他模块的接口和功能。

## 2. 架构设计 (Architecture Design)

- **整体架构图 (Overall Architecture)**: 核心架构不变，但 `AnalysisPanel` 内部的生命周期管理将得到修正。

  ```mermaid
  graph TD
      subgraph AnalysisPanel
          A[Engine Selector UI] -->|User selects engine| B{_switch_to_engine}
          B --> C[_cleanup_current_engine]
          C -->|Destroys old| D[AnalysisComponentsManager]
          C -->|Destroys old| E[UI Widgets]
          B -->|Creates new| D
          B -->|Creates new| E
      end

      F[analysis_calculator] -->|analysis_finished signal| D
      D -->|Updates| E
  ```

- **数据/信号流 (Data/Signal Flow)**:
  1. 用户通过UI选择新的渲染引擎并点击“应用”。
  2. `AnalysisPanel` 的 `_apply_engine_change` 方法触发 `_switch_to_engine`。
  3. **（新）** `_switch_to_engine` 首先调用 `_cleanup_current_engine` 方法。
  4. `_cleanup_current_engine` 负责断开现有 `AnalysisComponentsManager` 的所有信号连接，并调用 `deleteLater()` 将其销毁。同时，销毁所有当前显示的UI组件。
  5. `_switch_to_engine` 接着 **按需创建** 新渲染引擎对应的UI组件和 **唯一** 的 `AnalysisComponentsManager` 新实例。
  6. 新的管理器连接所需信号，UI恢复正常交互。

## 3. 组件与接口设计 (Component & Interface Design)

- **核心组件**: `AnalysisPanel`
- **组件职责**:
  - **现有职责**: 渲染引擎切换的UI交互。
  - **新增/强化职责**: **严格管理**其子组件（分析图表）和逻辑控制器（`AnalysisComponentsManager`）的完整生命周期，确保在切换时旧资源被彻底清理。
- **接口定义**:
  - 公共接口（如 `request_analysis_update`）保持不变。
  - **新增私有方法**: `_cleanup_current_engine()`:
    - **功能**: 负责清理当前激活的引擎所关联的所有资源。
    - **实现**: 检查 `self.analysis_manager` 是否存在，若存在则调用其 `deleteLater()`。遍历当前引擎的UI组件并调用 `deleteLater()`。
- **内部状态**:
  - `self.matplotlib_widgets` 和 `self.pyqtgraph_widgets` 将被移除。UI组件将在 `_switch_to_engine` 中按需创建，而不是在初始化时全部创建。

## 4. 数据模型 (Data Model)

本次重构不涉及数据模型的更改。

## 5. 错误处理 (Error Handling)

- **异常场景**: 在切换过程中，新的UI组件或管理器创建失败。
- **处理策略**: 由于旧资源已被清理，若新资源创建失败，界面将处于空白状态。此时应记录详细错误日志，并可考虑向用户显示一个错误提示信息。

## 6. 实施计划 (Implementation Plan)

- **阶段一: 实现清理逻辑**
  - 在 `AnalysisPanel` 中实现 `_cleanup_current_engine()` 私有方法。
- **阶段二: 重构切换与创建逻辑**
  - 修改 `_switch_to_engine` 方法，在开头调用 `_cleanup_current_engine()`。
  - 移除 `_init_widgets` 中的预创建逻辑，改为在 `_switch_to_engine` 中按需创建。
- **阶段三: 验证与测试**
  - 手动测试，反复切换引擎，观察内存和UI响应。
  - （可选）编写自动化测试验证切换后旧对象是否被销毁。

## 7. 向后兼容性 (Backward Compatibility)

- **影响分析**: 无负面影响。这是一个纯粹的内部重构和bug修复，不会改变任何对外接口和现有功能。
- **兼容策略**: 无需特定策略。

## 8. 扩展性考虑 (Extensibility)

- **未来扩展点**: 添加新的渲染引擎（如Plotly）。
- **设计预留**: 本次重构后，添加新引擎的逻辑将非常清晰：只需在 `_switch_to_engine` 中增加一个新的 `if/elif` 分支，用于创建新引擎的组件即可，无需担心资源泄露。
